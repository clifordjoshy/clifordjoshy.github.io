<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Cpp - tool - clifpage</title><link>http://cliford.net/tools/cpp/</link><description>Cpp - tool - clifpage</description><generator>Hugo -- gohugo.io</generator><language>en-in</language><lastBuildDate>Sun, 07 May 2023 15:21:50 +0530</lastBuildDate><atom:link href="http://cliford.net/tools/cpp/" rel="self" type="application/rss+xml"/><item><title>NITCbase - a toy RDBMS</title><link>http://cliford.net/projects/nitcbase/</link><pubDate>Sun, 07 May 2023 15:21:50 +0530</pubDate><author>Author</author><guid>http://cliford.net/projects/nitcbase/</guid><description><![CDATA[<div class="featured-image">
                <img src="https://github.com/NITCbase/nitcbase.github.io/raw/main/static/img/FrontBannerLogo.png" referrerpolicy="no-referrer">
            </div>Links &nbsp;GitHub &nbsp;Website About NITCbase is a course aimed at an undergraduate student that guides them through the implementation of an elementary RDBMS. The database is designed to have 8 layers covered top-down as follows:
Frontend Interface: This layer interacts with the user, and translates high level SQL-like queries from the user into calls to appropriate methods of the lower layers. Schema Layer: All DDL (Data Definition Language) commands of NITCbase - such as commands for creating, deleting, opening, closing and renaming relations; commands for renaming attributes of a relation and so on - are directed to this layer.]]></description></item><item><title>Rubik's Cube Solver</title><link>http://cliford.net/projects/rubiks-cube-solver/</link><pubDate>Fri, 01 Oct 2021 17:50:33 +0530</pubDate><author>Author</author><guid>http://cliford.net/projects/rubiks-cube-solver/</guid><description>Links &amp;nbsp;GitHub &amp;nbsp;Thisthlethwaite Algorithm Reference About My implementation of a Rubik&amp;rsquo;s cube solver using the Thisthlethwaite algorithm. A solution can be found for any shuffled state in 45 moves or less.
The algorithm works by splitting the solving into various stages such that
each stage only uses a subset of the possible moves moves used in a stage will not be needed in any subsequent stages With the above restrictions, an iterative deepening depth-first search is conducted on the state space until a solution is obtained.</description></item><item><title>Minimax Chess Bot and GUI</title><link>http://cliford.net/projects/chess-bot/</link><pubDate>Wed, 09 Dec 2020 17:40:49 +0530</pubDate><author>Author</author><guid>http://cliford.net/projects/chess-bot/</guid><description><![CDATA[Links &nbsp;GitHub - Python Version &nbsp;GitHub - C&#43;&#43; Version About This is my implementation of a single-player chess game using the minimax algorithm (which is an algorithm that can be used to generate optimal solutions for a zero-sum two player game) with alpha-beta pruning. A GUI was also written to make use of the bot and provide a single-player chess game experience.
There were two separate implementations that I did.]]></description></item></channel></rss>